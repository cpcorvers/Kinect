// forum.processing.org/two/discussion/11304/
// multiple-monitors-primary-dragable-secondary-fullscreen

/********************
 * IMPORT
 *******************/
import gausstoys.core.*;
import processing.serial.*;

/********************
* INIT
*******************/
GaussSense gsMeta;
GaussSense[] gs = new GaussSense[2];
boolean showContour = false;
boolean testBoard = false;
int thld = 6 ; //Unit: Gauss
boolean horizontalGrid = true;

// background images
PImage playingfield;
String[] bgBoard = {"playingfield1.png", "playingfield2.png", "playingfield3.png", "playingfield4.png" };
int bgBoardIndex = 0;

PImage perspectives;
String[] bgScreen = {"perspective1.png",  "perspective3.png", "perspective4.png", "perspective5.png", "perspective6.png", "perspective7.png" };
int bgScreenIndex = 0;
PImage person_abstract;

float xp;  // width of the perspective
float zp;  // depth of the perspective
float scalefactor; //variable to create a 3D perspective in 2D rendering of the person image
float wp;
float hp;
float pawnCenterX;
float pawnCenterY;
int serverDisplayWidth = 1920;
int serverDisplayHeight = 1080;
int imagePersonWidth = 177; //width of the .png image
int imagePersonHeight = 408; //height of the .png image
int identity;
float direction;
int pawn_polarity;
float pawn_intensity;
float pawn_x;
float pawn_y;
float pawn_ID;
float recordD = 1000;
boolean taken = false;

// INIT 'databases'
Person p;
ArrayList<Person> boardPawns;
ArrayList<Person> screenPersons;
ArrayList<Person> historyPersons;

float scaleX = 1.4900; //1.373 //width of screen
float scaleY = 1.550; //1.350 //hight of screen
float offsetX = 10; // 76;
float offsetY = 10; // 65;

//INIT Display variables
int boardDisplayWidth = 1920;
int boardDisplayHeight = 1080;
int screenDisplayWidth = 1280;
int screenDisplayHeight = 800;

/********************
* SETTING & SETUP FUNCTION FOR BOARDSCREEN
*******************/
// final PApplet projector = new ProjectorSketch();

public void settings() {
  // size(displayWidth, displayHeight, "processing.awt.PGraphicsJava2D");
  fullScreen(P2D, 3);
  smooth(4);
}

void setup() {
  //size(displayWidth, displayHeight, JAVA2D);
  //smooth(4);
  noLoop();
  // stroke(-1);

// ADDED FOR OTHERS EYES PERCEPTION BOARD
  playingfield = loadImage(bgBoard[bgBoardIndex]);

  // List all serial ports
  // GaussSense.printSerialPortList();

  //Initialize the GaussSense
  for (int i = 0; i < 2; i ++) {
    gs[i] = new GaussSense(this, GaussSense.GSType.GAUSSSENSE_BASIC, Serial.list()[Serial.list().length - (i+1)], 115200);
    gs[i].setCalibrationFileName("BASIC-"+i+".data");
  }
  gsMeta = new GaussSense(this, GaussSense.GSType.GAUSSSENSE_BASIC, 2, 1);

  // Intitialize the arrays for pawns and persons
  boardPawns = new ArrayList<Person>();
  screenPersons = new ArrayList<Person>();
  historyPersons = new ArrayList<Person>();

  perspectives = loadImage(bgScreen[bgScreenIndex]);
  person_abstract = loadImage("27.png");

  // runSketch(new String[] { "--display=1", "--sketch-path=" + sketchPath(""), "Projector" }, new ProjectorSketch());

  println("Main's  sketchPath: \t\"" + sketchPath("") + "\"");
  println("Main's  dataPath: \t\"" + dataPath("") + "\"\n");
  println("Setup main sketch completed");

}

void draw() {
  background(250);
  // line(0, 0, width, height);
  // fill(0, 250, 0);
  // rect(width/2, height/2, 100,100);

  // ADDED FOR OTHERS EYES PERCEPTION BOARD
  pushMatrix();
  translate(boardDisplayWidth, 0);
  rotate (PI/2);
  // image(playingfield, 0,  0, displayHeight, displayWidth );
  image(playingfield, 0,  0, displayHeight, displayWidth );
  popMatrix();

  //Set variables for drawing single-layer contour map
  //Try to change the Thld to see the results
  int upsampleFactor = 5;

  for (int i = 0; i < 2; i ++) {
    if (gs[i].getAdditionalData().size()>0) {
      int s = gs[i].getAdditionalData().get(0);
      //println(s);
      if (s == '1') gsMeta.set(gs[i], 0, 0, 2, false, false);
      if (s == '2') gsMeta.set(gs[i], 1, 0, 2, false, false);
    }
  }

  // // show visuals as generated by the GaussSense product and software if showContour == true in INIT
  // pushMatrix();
  //   translate(offsetX, offsetY);
  //   scale(scaleX, scaleY);
  //   if (showContour) {
  //     //Set and draw the upsampled contour map
  //      gsMeta.drawUpsampledContourMap2D(1280, 640, upsampleFactor, thld);
  //   } else {
  //     //Set but don't draw the upsampled contour map
  //     gsMeta.setUpsampledContourMap2D(1280, 640, upsampleFactor, thld);
  //   }
  //   // gsMeta.drawBasicGaussBits(); //draw a circle around the sensed magnets
  // popMatrix();

  //receive data from GaussSense, create Person in Arraylists and add Person.parameters using class Person
  getGaussData();

  //visualise a pawn on the boardscreen and send Person.parameters to the clients
  dataVisualisation();

  runSketch(new String[] { "--display=1", "--sketch-path=" + sketchPath(""), "Projector" }, new ProjectorSketch());

  // println(boardPawns.size() + " " + screenPersons.size() + " " + historyPersons.size());

  // runSketch(new String[] { "--display=3", "--sketch-path=" + sketchPath("/Users/PeterMacBookPro/Documents/Coding/Kinect/SatisactionPerceptionBoardSketchCombined/"), "Projector" }, projector);
}

class ProjectorSketch extends PApplet {
  void settings() {
  // size(displayWidth, displayHeight, "processing.awt.PGraphicsJava2D");
  fullScreen(P2D, 2);
  smooth(4);
  }
  void setup() {
    //size(displayWidth, displayHeight, JAVA2D);
    // noLoop();
    // stroke(#FFFF00);
    println("Inner's  sketchPath: \t\"" + sketchPath("") + "\"");
    println("Inner's  dataPath: \t\"" + dataPath("") + "\"\n");
  }

  void draw() {
    background(0);
    // line(width, 0, 0, height);
    // println(projector1);
    pushMatrix();
    image(perspectives, 0, 0, screenDisplayWidth, screenDisplayHeight);

    if (boardPawns.size() > 0){
      for (int i = 0; i < boardPawns.size(); i++){
        Person p = boardPawns.get(i);
        // p.showPerson(p.pawnCenterX, p.pawnCenterY, p.identity, p.direction);
        scalefactor = map(pawnCenterX, serverDisplayHeight, 0, 2.8, 0.9);
        zp = map(pawnCenterX, 0, serverDisplayWidth, 800, 100);
        xp = map(pawnCenterY, 0, serverDisplayHeight, 100, 1800);
        wp = (imagePersonWidth / scalefactor);
        hp = (imagePersonHeight / scalefactor);
        image(person_abstract, xp, zp, wp, hp);
        textSize(20);
        fill(0, 102, 153);
        text(identity, xp, zp);
      }
    }

    // image(person_abstract, x, y, 50, 100);
    println("Draw boardPawns");

    popMatrix();

    // sketchPath = "/Users/PeterMacBookPro/Documents/Coding/Kinect/SatisactionPerceptionBoardSketchCombined/" ;//args[0]; // re-assign it w/ correct main sketch's path.
    // println("Inner's fixed dataPath: \"" + dataPath("") + "\"\n");
  }
}



void dataVisualisation() {
  // show every person which is taken==true
  for (Person p : boardPawns) {
    if ( p.pawn_polarity == 1) { //p.taken == true &&
      p.getPawnCenter();
      p.showPawn(p.pawnCenterX, p.pawnCenterY, p.identity, p.direction);
    }
    println("dataVisualisation");
  }

}

void getGaussData() {
  //Receive data from the GaussSense sensors and store in an Arraylist
  ArrayList<GData> bGaussBitsList = gsMeta.getBasicGaussBits(thld);//API Demos
  for (int j=0; j < bGaussBitsList.size(); j++) {
    GData bGaussBits = bGaussBitsList.get(j);
    int polarity = bGaussBits.getPolarity(); //Get the polarity in Int. 0: North, 1:South
    int intensity = (int) bGaussBits.getIntensity(); //Get the intensity. Unit: gauss
    int x = round((int) bGaussBits.getX()); //Get the X coordinate on the display
    int y = round((int) bGaussBits.getY()); //Get the Y coordinate on the display
    // String polarityString = (polarity==0 ? "North" : "South" );
    int xx = round(((int) x * scaleX));
    int yy = round(((int) y * scaleY));
    // store data in the ArrayList boardPawns every .. millisecond
    // for (int i = 0; i <= 100; i++){
    //   if (i == 100) {
        boardPawns.add(new Person(xx, yy, polarity, intensity));
        historyPersons.add(new Person(xx, yy, polarity, intensity));
    //   }
      println("getData added: " + boardPawns);
    // }

    // if the ArrayList boardPawns is bigger then the sensorlist,
    if (boardPawns.size() > bGaussBitsList.size()) {
      // then move the pawn record to historyPersons
      for (int i = 0; i < (boardPawns.size() - bGaussBitsList.size()); i++){
        Person hp = boardPawns.get(i);
        // historyPersons.add(hp);
        boardPawns.remove(i);
      }


    };

// send the GaussSense data to the clients
    // if (intensity>0) s.write( j + " " + polarity+ " " + intensity + " " + x + " " + y +  " " + xx + " " + yy + "\n" );
  }
  // Empty ArrayList boardPawns when sensors give no data
  if (bGaussBitsList.size() == 0){ emptyBoardPawns(); }
  // Avoiding full of memory exeption by restricting the size of the ArrayLists
  if (boardPawns.size() > 200) {
    for (int i = 0; i < (boardPawns.size() - 200); i++){ boardPawns.remove(i); }
  }
  if (screenPersons.size() > 200) {
    for (int i = 0; i < (screenPersons.size() - 200); i++){ screenPersons.remove(i); }
  }
  if (historyPersons.size() > 50) {
    for (int i = 0; i < (historyPersons.size() - 50); i++){ historyPersons.remove(i); }
  }
}

void emptyBoardPawns(){
  for (int i = 0; i < boardPawns.size(); i++) {
    Person cp = boardPawns.get(i);
    boardPawns.remove(i);
  }
}

void keyPressed() {
  //CHANGING PLAYINGFIELD BACKGROUND WITH Q AND W KEYPRESS
  if (key == 'q') {
    if (bgBoardIndex > 0) {
      bgBoardIndex-- ;
    } else {
      bgBoardIndex = bgBoard.length-1;
    }
    playingfield = loadImage(bgBoard[bgBoardIndex]);
  } else if (key == 'w') {
    if (bgBoardIndex < (bgBoard.length-1)) {
      bgBoardIndex++ ;
    } else {
      bgBoardIndex = 0;
    }
    playingfield = loadImage(bgBoard[bgBoardIndex]);
  } else if (key == 'o') {
    if (bgScreenIndex > 0) {
      bgScreenIndex-- ;
    } else {
      bgScreenIndex = bgScreen.length-1;
    }
    perspectives = loadImage(bgScreen[bgScreenIndex]);
  } else if (key == 'p') {
    if (bgScreenIndex < (bgScreen.length-1)) {
      bgScreenIndex++ ;
    } else {
      bgScreenIndex = 0;
    }
    perspectives = loadImage(bgScreen[bgScreenIndex]);
  }
}
